%Load Signal
[Signal,sampling1,bits1] = wavread('27Apr09_174921_026_p1.wav');
[Signal2,sampling2,bits2] = wavread('27Apr09_174921_026_p3.wav');

%Times
primerevento_inicial=13440000;
primerevento_final=15840000;
segundoevento_inicial=49920000;
segundoevento_final=51840000;

%¡ lenght, sample freq and print
[fileLength2,num_channels2]=size(Signal2);
[fileLength1,num_channels1]=size(Signal);
duration1=fileLength1/sampling1;
duration2=fileLength2/sampling2;
text1=sprintf(' Signal1. Sampling frequency: %d Hz.\n Number of samples: %d\n Time duration: %.1f seconds', sampling1, fileLength1, duration1)
text2=sprintf(' Signal2. Sampling frequency: %d Hz.\n Number of samples: %d\n Time duration: %.1f seconds',  sampling2, fileLength2, duration2)
DEBUG=1;
Fs=sampling1;

%Cut the SIGNAL
inicio=primerevento_inicial;
final=primerevento_final;


Signalcortada=Signal(inicio:final);
Signal2cortada=Signal2(inicio:final);
M =length(Signalcortada)


%% BACKGROUND NOISE
% Let us compute the PSD of the background noise in Signalcortada, for
% later use. It appears that the noise is pink, 
L=1;
L2=560000;
real_noise=Signalcortada(L:L2);
real_noise_std=std(real_noise)

clf;
pwelch(real_noise,[],[],[],Fs);
%% FILTER FROM 1Khz to 12Khz

%clear ax;
%cortada=0.33*length(Signal);
%time=(0:cortada-1)/Fs;
%ax(1)=subplot(3,1,1); plot(time,Signal)
%ylabel('Amplitude');
%title('Signal #1');
%hold on;
%ax(2)=subplot(3,1,2); plot(time,Signal2)
%ylabel('Amplitude');
%title('Signal #2');
%linkaxes(ax,'x');
%zoom
%set(gca,'xlim',[6.66 6.73]);
% Let us listen to the first two clicks at hydrophone #1. 
%soundsc(Signal(150*Fs:165*Fs),Fs);

 Fs=96e3; % 96 KHz
    
        % 1. hydrophone signal is not zero mean :0
        signal1 = Signalcortada - mean(Signalcortada);
        % signal1= input;

        % 2. Just looking for minke whales
        % Band-pass filter
        % Generated by MATLAB(R) 8.1 and the DSP System Toolbox 8.4.
        % Generated on: 22-Nov-2013 14:26:55
        % Chebyshev Type I Bandpass filter designed using FDESIGN.BANDPASS.
        % All frequency values are in Hz.
        Fs = 96000;  % Sampling Frequency
        N      = 50;     % Order
        Fpass1 = 1e3;   % First Passband Frequency
        Fpass2 = 12e3;  % Second Passband Frequency
        Apass  = 1;      % Passband Ripple (dB)
        % Construct an FDESIGN object and call its CHEBY1 method.
        h  = fdesign.bandpass('N,Fp1,Fp2,Ap', N, Fpass1, Fpass2, Apass, Fs);
        Hd = design(h, 'cheby1');
        signal2 = sosfilt(Hd.sosMatrix,signal1);
        % DEBUG: visualize the frequency response of the filter
       % fvtool(Hd);
        % signal2=signal1;
        Signalcortada=signal2;
        
        
        %LA SEGUNDA
       signal1 = Signal2cortada - mean(Signal2cortada);
        signal2 = sosfilt(Hd.sosMatrix,signal1);
        Signal2cortada=signal2;
        
        figure(1)  
plot(Signalcortada)
figure(2)  
plot(Signal2cortada)
        

%% Time Gain normalization

Signalcortada=time_gain(Signalcortada);
Signal2cortada=time_gain(Signal2cortada);

figure  
specgram(Signalcortada,1024,Fs,556);




%%
%PERCENTIL NOISE REMOVAL
Signalprocesada=percentile(Signalcortada,90,Fs,5);
Signal2procesada=percentile(Signal2cortada,90,Fs,5);

figure(1)
plot(Signalprocesada)
figure(2)
plot(Signalcortada)
figure(3) 
specgram(Signalprocesada,1024,Fs)
figure(4) 
specgram(Signalcortada,1024,Fs)

  
%%
%Spectralsubstraction
Signalprocesada=spectralsubstraction(Signalcortada,Fs,5,0.0001);
Signal2procesada=spectralsubstraction(Signal2cortada,Fs,5,0.0001);

figure(1)
plot(Signalprocesada)
figure(2)
plot(Signalcortada)
figure(3) 
specgram(Signalprocesada,1024,Fs)
figure(4) 
specgram(Signalcortada,1024,Fs)
%%

gamma=2;

Window_length=(Fs*0.075);   %75 ms
Window_overlap=(Fs*0.0375);    %37.5 ms
NFFT=2048;
Noise_Frames=Signalcortada(1:19200);    %The first second of the simulation! It is noise!
NumOfFrames=floor(length(Signalcortada)/Window_overlap);
NumOfNoiseFrames=floor(length(Noise_Frames)/Window_overlap);
Window=hann(Window_length); % A Hann window is chosen
windowEnergy=sum(Window.^gamma);
Window=Window.*sqrt(Window_length/windowEnergy); % Normalization of the window 

ProcessedSignal=zeros(length(Signalcortada),1);  
 
for k=1:NumOfNoiseFrames-1   %Estimate the NOISE SPECTROGRAM
    
   index1=(k-1)*(Window_overlap)+1;
   index2=(k-1)*(Window_overlap)+Window_length;
   Frame=Noise_Frames(index1:index2);
   WindowedFrame=Frame.*Window;
   FrameFFT=fft(WindowedFrame);
   FrameSpec=((abs(FrameFFT)).^gamma)*(1/Window_length);
   S(:,k)=FrameSpec;    
end

F=length(FrameFFT);
    for i=1:F
    N(i)=prctile(abs(S(i,:)),90);     %Calculate the percentile vector of the NOISE FRAMES
   end

    for k=1:NumOfFrames-1     %Calculating the signal spectrogram
    
   index1=(k-1)*(Window_overlap)+1;
   index2=(k-1)*(Window_overlap)+Window_length;
   Frame=Signalcortada(index1:index2);
   WindowedFrame=Frame.*Window;
   FrameFFT=fft(WindowedFrame);
   FrameSpec=((abs(FrameFFT)).^gamma)*(1/Window_length);
   Sx(:,k)=FrameSpec;    
   
    end

    
  for i=1:(NumOfFrames-1)                        %Substract the Percentile process!
   index1=(i-1)*(Window_overlap)+1;
   index2=(i-1)*(Window_overlap)+Window_length;
    FramePhase=angle(Sx(:,i));  %cCalculate the phase to reconstruct
   
      
         FrameSpec=max(abs(Sx(:,i))-5.*N',0);   %Substract the Percentile
         
        
         
% Re-synthesize the cleaned speech frame using the phase of the noisy frame   
   FrameOutputFFT= sqrt(FrameSpec).*cos(FramePhase) +...
       i.*sqrt(FrameSpec).*sin(FramePhase);
   FrameOutput=real(ifft(FrameOutputFFT,Window_length)).*sqrt(Window_length);
   
   ProcessedSignal(index1:index2)= ProcessedSignal(index1:index2) +...
       FrameOutput;
  
    
  % Notice the frames are 50% overlapped
  end
  output=ProcessedSignal;
  
  figure
   plot(output)
   figure
   specgram(output,1024,Fs,556);
  % spectrogram(output,Window,Window_overlap,NFFT);
   figure
   plot(Signalcortada)
   figure
   specgram(Signalcortada,1024,Fs,556);
   %spectrogram(Signalcortada,Window,Window_overlap,NFFT);

   %%
   
   sounsc(output,Fs)
%% Frequency band normalization
Signalresultant=freq_band(Signalcortada,Fs);
Signal2resultant=freq_band(Signal2cortada,Fs);

%PLOT ALL
figure(1) 
plot(Signalresultant)
figure(2)
plot(Signalcortada)





%% TK FILTER
Signalcortadatk=teager_kaiser(Signalcortada);
Signal2cortadatk=teager_kaiser(Signal2cortada);

%PLOT ALL
%ax(1)=subplot(3,1,1);
%plot(Signalcortada);
%ylabel('Amplitude');
%ax(2)=subplot(3,1,2);
%plot(Signalcortadatk);
%ylabel('Amplitude');
%linkaxes(ax,'x');

%figure
%ax(1)=subplot(4,1,1);
%plot(Signal2cortada);
%ylabel('Amplitude');
%ax(2)=subplot(4,1,2);
%plot(Signal2cortadatk);
%ylabel('Amplitude');
%linkaxes(ax,'x');



%% TDE PROCESS THE TIME DELAY STIMATION WITH CC GCC CTE,PHAT,SCOT
gcc_mode = 'scot';
gcc_mode1 = 'cc';
gcc_mode3 = 'phat';
Signal_a_correlar=Signalprocesada;
Signal_a_correlar2=Signal2procesada;

%Xcorr
xcorr_ballena = xcorr(Signal_a_correlar,Signal_a_correlar2);
[val,ind]=max(xcorr_ballena );
delay_ball= ind-M
delay_ball_s=delay_ball/Fs;
%Gcorr normal
gcorr_ballena = gcc_marques_nuevo(Signal_a_correlar,Signal_a_correlar2,gcc_mode1);
[val,ind]=max(gcorr_ballena );
delay_ballgccn= ind-M
delay_ballgccn_cte=delay_ballgccn/Fs;
%Gcorr scot
gscorr_ballena = gcc_marques_nuevo(Signal_a_correlar,Signal_a_correlar2,gcc_mode);
[val,ind]=max(gscorr_ballena );
delay_ballgccs= ind-M
delay_ballgcc_scot=delay_ballgccs/Fs;
%Gcorr phat
gpcorr_ballena = gcc_marques_nuevo(Signal_a_correlar,Signal_a_correlar2,gcc_mode3);
[val,ind]=max(gpcorr_ballena );
delay_ballgccp= ind-M
delay_ballgcc_phat=delay_ballgccp/Fs;

%plot ALL 
if DEBUG
    figure(1)
    plot(xcorr_ballena); title('xcorr between whales');
    
    figure(4)
    plot(gcorr_ballena); title('gcorr between whales');
 
   figure(2)
    plot(gpcorr_ballena); title('gcorr-phat between whales');
    
  figure(3)
    plot(gscorr_ballena); title('gcorr Scot between whales');
end


%%
%NOTHING!! FOR ME (TEMPORAL)

% We run the adaptive filtering algorithm for TDOA estimation within [-600,600]
% (samples) and step |mu|=0.01 (for full scale signals in [-1,+1]).

% Normalizing max signal amplitudes to +1
x1=signal_1_tk/max(signal_1_tk);
x2=signal_2_tk/max(signal_2_tk);

% LMS initialization
M = 600; % max value of the estimated TDOA
x1c = zeros(M,1);
x2c = zeros(M,1);
u = zeros(2*M,1);
u(M/2) = 1;
N = length(x1);
e = zeros(1,N);
tdoa = zeros(1,N);
peak = zeros(1,N);
mu = 0.01; % LMS step

% LMS loop
for n=1:N
    
    x1c = [x1(n);x1c(1:length(x1c)-1)];
    x2c = [x2(n);x2c(1:length(x2c)-1)];
    x = [x1c;x2c];
    
    e(n) = u'*x;
    u = u-mu*e(n)*x;
    u(M/2) = 1; %forcing g2 to an impulse response at M/2
    u = u/norm(u); %forcing ||u|| to 1
    
    [peak(n),ind] = min(u(M+1:end));
    peak(n)=-peak(n); % find the value of the (positive) impulse
    TDOA(n) = ind-M/2;
    
end

% Estimated TDOA as a function of time, with values of the peak in h1
subplot(2,1,1);
plot(TDOA);
xlabel('Time (samples)'); ylabel('TDOA (samples)');
subplot(2,1,2);
plot(peak);
xlabel('Time (samples)'); ylabel('peak');

%% TDE Eigenvalue Descomposition
Signal_a_correlar=Signalcortada;
Signal_a_correlar2=Signal2cortada;

R=toeplitz(Signal_a_correlar,Signal_a_correlar2);
[eigenvec,lambda]=eig(R);   %sacar eigenvectors y eigenvalues
if (length(R)==length(eigenvec))   %mirar que tengan el mismo rango (R y eigenvec)
    
    
   %caso no ruido
   %Buscar el eigenvalue 0. Entonces coger el
    %vector de ese eigenvalue sera el chanel response u=(h1,-h0) de la señal
    %Rx0x1. 
    %Despues, miramos que h1 y h0 no contengan ningun 0 en comun
    %finalmente, T=argmax h1,l - argmax h0,l   con valores abs
    
    %caso ruido
    %u(k+1)=   (u(k)-mu*error*x)/(norma(u-mu*error*x))  con norma(u)2=1 con
    %error=u*x     PROBLEMA DE INICIALIZAR!!! LEER MAÑANA    
    
    
end

    
   
    
    


%% DEBUG: no need of aux. variables
if ~DEBUG
    clear('DEBUG','peak*','xcorr*')
end